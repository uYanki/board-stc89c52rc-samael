#include "lib_oled.h"

// 本来想把这字体写在 font.h 里的, 奈何在编译时报程序空间不够, 编译失败,
// 就把字体放在这个文件里, 编译又通过了, 也是醉了
#if FONT_6x8
const unsigned char code F6x8[][6] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // space
    0x00, 0x00, 0x00, 0x2f, 0x00, 0x00,  // !
    0x00, 0x00, 0x07, 0x00, 0x07, 0x00,  // "
    0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14,  // #
    0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12,  // $
    0x00, 0x62, 0x64, 0x08, 0x13, 0x23,  // %
    0x00, 0x36, 0x49, 0x55, 0x22, 0x50,  // &
    0x00, 0x00, 0x05, 0x03, 0x00, 0x00,  // '
    0x00, 0x00, 0x1c, 0x22, 0x41, 0x00,  // (
    0x00, 0x00, 0x41, 0x22, 0x1c, 0x00,  // )
    0x00, 0x14, 0x08, 0x3E, 0x08, 0x14,  // *
    0x00, 0x08, 0x08, 0x3E, 0x08, 0x08,  // +
    0x00, 0x00, 0x00, 0xA0, 0x60, 0x00,  // ,
    0x00, 0x08, 0x08, 0x08, 0x08, 0x08,  // -
    0x00, 0x00, 0x60, 0x60, 0x00, 0x00,  // .
    0x00, 0x20, 0x10, 0x08, 0x04, 0x02,  // /
    0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E,  // 0
    0x00, 0x00, 0x42, 0x7F, 0x40, 0x00,  // 1
    0x00, 0x42, 0x61, 0x51, 0x49, 0x46,  // 2
    0x00, 0x21, 0x41, 0x45, 0x4B, 0x31,  // 3
    0x00, 0x18, 0x14, 0x12, 0x7F, 0x10,  // 4
    0x00, 0x27, 0x45, 0x45, 0x45, 0x39,  // 5
    0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30,  // 6
    0x00, 0x01, 0x71, 0x09, 0x05, 0x03,  // 7
    0x00, 0x36, 0x49, 0x49, 0x49, 0x36,  // 8
    0x00, 0x06, 0x49, 0x49, 0x29, 0x1E,  // 9
    0x00, 0x00, 0x36, 0x36, 0x00, 0x00,  // :
    0x00, 0x00, 0x56, 0x36, 0x00, 0x00,  // ;
    0x00, 0x08, 0x14, 0x22, 0x41, 0x00,  // <
    0x00, 0x14, 0x14, 0x14, 0x14, 0x14,  // =
    0x00, 0x00, 0x41, 0x22, 0x14, 0x08,  // >
    0x00, 0x02, 0x01, 0x51, 0x09, 0x06,  // ?
    0x00, 0x32, 0x49, 0x59, 0x51, 0x3E,  // @
    0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C,  // A
    0x00, 0x7F, 0x49, 0x49, 0x49, 0x36,  // B
    0x00, 0x3E, 0x41, 0x41, 0x41, 0x22,  // C
    0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C,  // D
    0x00, 0x7F, 0x49, 0x49, 0x49, 0x41,  // E
    0x00, 0x7F, 0x09, 0x09, 0x09, 0x01,  // F
    0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A,  // G
    0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F,  // H
    0x00, 0x00, 0x41, 0x7F, 0x41, 0x00,  // I
    0x00, 0x20, 0x40, 0x41, 0x3F, 0x01,  // J
    0x00, 0x7F, 0x08, 0x14, 0x22, 0x41,  // K
    0x00, 0x7F, 0x40, 0x40, 0x40, 0x40,  // L
    0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F,  // M
    0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F,  // N
    0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E,  // O
    0x00, 0x7F, 0x09, 0x09, 0x09, 0x06,  // P
    0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E,  // Q
    0x00, 0x7F, 0x09, 0x19, 0x29, 0x46,  // R
    0x00, 0x46, 0x49, 0x49, 0x49, 0x31,  // S
    0x00, 0x01, 0x01, 0x7F, 0x01, 0x01,  // T
    0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F,  // U
    0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F,  // V
    0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F,  // W
    0x00, 0x63, 0x14, 0x08, 0x14, 0x63,  // X
    0x00, 0x07, 0x08, 0x70, 0x08, 0x07,  // Y
    0x00, 0x61, 0x51, 0x49, 0x45, 0x43,  // Z
    0x00, 0x00, 0x7F, 0x41, 0x41, 0x00,  // [
    0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55,  // 国际象棋盘?
    0x00, 0x00, 0x41, 0x41, 0x7F, 0x00,  // ]
    0x00, 0x04, 0x02, 0x01, 0x02, 0x04,  // ^
    0x00, 0x40, 0x40, 0x40, 0x40, 0x40,  // _
    0x00, 0x00, 0x01, 0x02, 0x04, 0x00,  // '
    0x00, 0x20, 0x54, 0x54, 0x54, 0x78,  // a
    0x00, 0x7F, 0x48, 0x44, 0x44, 0x38,  // b
    0x00, 0x38, 0x44, 0x44, 0x44, 0x20,  // c
    0x00, 0x38, 0x44, 0x44, 0x48, 0x7F,  // d
    0x00, 0x38, 0x54, 0x54, 0x54, 0x18,  // e
    0x00, 0x08, 0x7E, 0x09, 0x01, 0x02,  // f
    0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C,  // g
    0x00, 0x7F, 0x08, 0x04, 0x04, 0x78,  // h
    0x00, 0x00, 0x44, 0x7D, 0x40, 0x00,  // i
    0x00, 0x40, 0x80, 0x84, 0x7D, 0x00,  // j
    0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,  // k
    0x00, 0x00, 0x41, 0x7F, 0x40, 0x00,  // l
    0x00, 0x7C, 0x04, 0x18, 0x04, 0x78,  // m
    0x00, 0x7C, 0x08, 0x04, 0x04, 0x78,  // n
    0x00, 0x38, 0x44, 0x44, 0x44, 0x38,  // o
    0x00, 0xFC, 0x24, 0x24, 0x24, 0x18,  // p
    0x00, 0x18, 0x24, 0x24, 0x18, 0xFC,  // q
    0x00, 0x7C, 0x08, 0x04, 0x04, 0x08,  // r
    0x00, 0x48, 0x54, 0x54, 0x54, 0x20,  // s
    0x00, 0x04, 0x3F, 0x44, 0x40, 0x20,  // t
    0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C,  // u
    0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C,  // v
    0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C,  // w
    0x00, 0x44, 0x28, 0x10, 0x28, 0x44,  // x
    0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C,  // y
    0x00, 0x44, 0x64, 0x54, 0x4C, 0x44,  // z
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14,  // horiz lines
};
#endif

void OLED_Init(void) {
    // 注: 命令顺序别乱调, 否则会导致初始化失败

    uint8_t code bytes[] = {
        0xAE,  // turn off oled panel

        0x20,  // set memory addressing mode 内存地址模式
        0x02,  // [1:0], 00,Horizontal Addressing Mode 列地址模式; 01,Vertical Addressing Mode 行地址模式; 10,Page Addressing Mode 页地址模式 (default); 11,Invalid

        0xC8,  // set COM output scan direction, COM 输出扫描方式 (行扫描顺序?)
        //【*】 0xC8 改 0xC0 可实现上下颠倒的效果

        0xB0,  // [2:0] set page start address for page addressing mode, 0-7
        0x00,  // set low column address
        0x10,  // set high column addres
        0x40,  // set start line address [5:0] 显示开始行, 0x40=64=2^6

        0x81,  // set contrast ratio 对比度
        0x7F,  // 1~255, 值越大越亮

        0xA1,  // set segment re-map 0 to 127, 段重映射 (列扫描顺序?)
        //【*】 0xA1 改 0xA0 可实现左右翻转的效果

        0xA6,  // set dispaly mode 显示模式, bit0: 1 reverse 反显, 0 normal 正常
        //【*】 0xA6 改 0xA7 可实现反显的效果

        0xA8,  // set multiplex ratio 复用率 (分辨率?)
        0x3F,  // 1 to 64,  0x3F:128*64, 0x1F:128*32

        0xA4,  // bit0: 0(0xa4) Output follows RAM content, 1(0xa5) Output ignores RAM content
        // 【*】 0xA5 点亮全屏, 在没开启反转的情况下, 全屏变白

        0xD3,  // set display offset 显示偏移
        0x00,  // not offset 无偏移

        0xD5,  // set display clock divide ratio/oscillator frequency 时钟分频因子 & 震荡频率
        0xF0,  // [3:0]:分频因子, [7:4]:震荡频率

        0xD9,  // set pre-charge period 预充电周期
        0x22,  // [3:0] PHASE 1, [7:4] PHASE 2

        0xDA,  // set com pins hardware configuration, COM 引脚硬件配置
        0x12,  // [5:4]

        0xDB,  // set VCOMH 电压倍率
        0x30,  // [6:4] 000,0.65*vcc, 001(0x20):0.77*vcc, 011(0x30):0.83*vcc

        0x8D,  // set DC-DC enable 电荷泵
        0x14,  // bit2: 1开启,0关闭

    };

    uint8_t i, j = ARRAY_LEN(bytes);

    for (i = 1; i < j; ++i) OLED_WriteCmd(bytes[i]);

    OLED_Clear();

    OLED_WriteCmd(0xAF);  // turn on oled panel
}

void OLED_Fill(uint8_t byte) {
    uint8_t i, j;
    for (i = 0; i < 8; ++i) {
        OLED_WriteCmd(0xB0 | i);  // page0 - page7
        OLED_WriteCmd(0x00);      // low column start address
        OLED_WriteCmd(0x10);      // high column start address
        for (j = 0; j < 128; ++j)
            OLED_WriteData(byte);
    }
}

void OLED_On(void) {
    // set DC-DC enable
    OLED_WriteCmd(0x8D);
    OLED_WriteCmd(0x14);
    // turn on oled panel
    OLED_WriteCmd(0xAF);
}
void OLED_Off(void) {
    // set DC-DC disable
    OLED_WriteCmd(0x8D);
    OLED_WriteCmd(0x10);
    // turn off oled panel
    OLED_WriteCmd(0xAE);
}

void OLED_SetContrast(uint8_t contrast) {
    OLED_WriteCmd(0x81);
    OLED_WriteCmd(contrast);
}
void OLED_SetInvert(uint8_t bool /* normal:0,invert:1 */) {
    OLED_WriteCmd(bool ? 0xA7 : 0xA6);
}

void OLED_HorizontalScroll(uint8_t dir /*0=left,1=right*/, uint8_t start /* page: 0~7 */, uint8_t stop /* page: 0~7 */) {
    // 水平滚动(注意不要放在循环里)
    OLED_StopScroll();
    OLED_WriteCmd(dir ? 0x26 : 0x27);  // right
    OLED_WriteCmd(0x00);
    OLED_WriteCmd(start);
    OLED_WriteCmd(0x00);
    OLED_WriteCmd(stop);
    OLED_WriteCmd(0X00);
    OLED_WriteCmd(0XFF);
    OLED_StartScroll();
}

void OLED_SetCursor(uint8_t page /* 0~7 */, uint8_t col /* 0~127 */) {
    OLED_WriteCmd(0xb0 | page);
    OLED_WriteCmd(((col & 0xF0) >> 4) | 0x10);
    OLED_WriteCmd(col & 0x0F);
}

#if FONT_6x8 || FONT_8x16  // 启用字体

void OLED_ShowChar(uint8_t ch) {
    uint8_t i;
    ch -= ' ';
    for (i = 0; i < 6; ++i) {
#if FONT_6x8
        OLED_WriteData(F6x8[ch][i]);
#endif
    }
}

void OLED_ShowStr(uint8_t* str) {
    while (*str) OLED_ShowChar(*str++);
}

// 可能因为 RAM 不够, 数字大了就递归就出错, 所以不用 uint32_t, 而用 uint16_t
void OLED_ShowNum(uint16_t num) reentrant {
    if (num > 9) OLED_ShowNum(num / 10);
    OLED_ShowChar(num % 10 + '0');
}

void OLED_ShowHex(uint16_t num) reentrant {
    char val;
    if (num > 15)
        OLED_ShowHex(num / 16);
    val = num % 16;
    if (val < 10)
        OLED_ShowChar('0' + val);
    else
        OLED_ShowChar('A' + val - 10);
}

// @font 6x8 (不支持换行符、制表符等)
void OLED_ShowStrL(uint8_t page, uint8_t col, uint8_t* str) {
    OLED_SetCursor(page, col);
    while (*str) {
        if (col >= (127 - 6))
            OLED_SetCursor(page += 1, col = 0);
        OLED_ShowChar(*str++);
        col += 6;
    }
}

#endif